---

title: JPA와 Index를 친해지게 하기

date: 2023-07-07
categories: [JPA, MySQL, Index]
tags: [JPA, MySQL, Index]
layout: post
toc: true
math: true
mermaid: true

---

# 문제 상황

현재 진행하는 프로젝트에서 특정 키워드가 포함된 레코드를 모두 조회하는 요구사항이 있었다.

현재 레코드 수는 아래 그림과 같이 약 165570개 이고, 매 1시간마다 800 ~ 1200개의 레코드가 추가되는 테이블을 사용하고 있다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/b5652947-38a4-42c4-b6e6-a909d65e0b52)

위 요구사항을 해결하기 위한 로직을 처리하는데 아래와 같이 12초 ~ 13초의 시간이 소요되어 이를 개선하고자 한다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/dbd5d34f-8329-42dd-b23d-848f96bb9cc0)

---

# 문제 분석

문제의 원인이 무엇인지 살펴보기 위해 쿼리를 살펴보면 아래와 같다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/b95ff053-6f4f-4142-8e8f-f2a61098a917)

**news**라는 테이블의 모든 레코드를 Full Scan하면서 조건에 맞는 레코드를 가져오는 로직이다.

여기서 문제가 발생한 것이였다. 레코드 수가 너무 많기 때문에 A-Z까지 도달하는 시간 자체가 길어진 것이다.

이를 해결하려면 어떻게 해야할까? 내가 생각했던 해결책은 아래와 같다.

- 특정 조건에 부합하는 레코드를 포인터로 찝어서 조회를 수행한다. (커서 페이징과 유사한 해결방식)
- DB에 인덱스를 적용하여 조회 시 성능을 더 높일 수 있도록한다. (인덱스가 뭔지는 구체적으로 몰랐다.)

일단 첫 번째 방법은 차선책으로 해결하기로 하고 여기저기서 많이 들어본 인덱스를 활용하여 해결해보기로 결정했다.

---

# 해결 과정

**보조 인덱스를 어떤 컬럼을 지정해야하는가?** 를 고민하기 시작했다.

인덱싱의 원리의 따르면 보조 인덱스는 **조회할 때 사용할 조건 컬럼**이 되어야하고 **되도록 중복되지 않는 것**이 성능 개선에 더 좋다고 한다.

위 사항을 고려하여 조회할 테이블의 레코드를 살펴보면 어떤 것을 보조 인덱스로 지정할 지 결정하면된다.

## 인덱스란?

**Real MySQL**이라는 책을 읽고있다고 가정해보자.

여기서 나는 **인덱스**라는 챕터의 내용을 읽고싶으면 어떻게 하는가?

- 첫 장부터 **인덱스 챕터**가 나올 때 까지 일일히 넘긴다.
- 목차를 활용해서 **인덱스 챕터**가 나오는 페이지를 확인하고 이동한다.

둘 중 어떤 방법이 더 빠르게 **인덱스 챕터**를 찾을 수 있을까?

만약에 페이지 수가 굉장히 적고 첫 페이지부터 인덱스 챕터가 등장한다면 첫 번째 방법이 빠를 것이다.

하지만 보통 책은 그렇지 않다. 여러 내용을 소개하는 챕터가 분류되어있고 책의 분량도 다양하게 제작된다.

따라서 보편적으로는 목차를 읽고 원하는 챕터가 나오는 페이지로 넘긴다.

이 상황을 DBMS의 데이터를 조회할 때 적용하는 것이 **인덱스** 방식이다.

**인덱스 == 책의 목차 페이지** 라고 생각하면 좋을 것 같다.

## 인덱스가 무작정 좋기만 할까?

### 인덱스가 독이 될 수 있는 상황 1

아까 들었던 예시에서 찾고자하는 대상인 "인덱스 챕터"에 관한 데이터가 많다면 문제가 생긴다.

즉, 10개의 챕터 중 **"인덱스"** 라는 단어가 들어간 챕터가 10개라면? 이런식으로 찾아서는 인덱스가 거의 무용지물이다. 오히려 일일히 책을 뒤져보는 것 보다 **성능이 더 느린 상황이 발생**할 수도 있다.

### 인덱스가 독이 될 수 있는 상황 2

또한 기존 책이 1000페이지라고 했을 때 인덱스 역할을 하는 **목차**를 나타내는 페이지가 없다면 1000쪽으로 끝날 것이다.

하지만, 인덱스를 추가하면서 부가적인 쪽수가 늘어나게 된다.

DBMS에도 마찬가지로 인덱스를 관리하기 위한 **추가적인 리소스가 소모**된다.

인덱스는 일반적으로 10% ~ 20%의 공간을 추가로 요구한다.

### 인덱스가 독이 될 수 있는 상황 3

책의 내용이 1000페이지인데 **500페이지 쯤에서 내용을 추가해야한다**고 해보자

이 상황에선 당연하게도 **페이지의 내용을 추가하는 것**과 더불어 **인덱스를 관리하는 목차 또한 모두 고쳐**야한다.

이 역시 **인덱스의 내부 구현이 LinkedList와 유사한 B-Tree방식**으로 구현되어있기 때문이다.

---

결론적으로 인덱스는 대용량 테이블에 적용한다면 성능 개선을 기대할 수 있지만 그렇지 않다면 오히려 리소스를 더 사용하고, 조회 성능 까지도 느리게 만들 수 있다.

또한, 삽입/변경/삭제 등이 자주 일어나는 테이블에는 적절한 방법이 아니다.

## 인덱스 종류

인덱스도 종류가 나뉜다. 일반적으론 크게 **클러스터형** 인덱스, **보조** 인덱스 두 가지로 나뉜다.

### 인덱스 종류 - 클러스터형 인덱스

클러스터형 인덱스는 **국어사전**과 비슷하다.

즉, 그 자체로 이미 정렬되어있어 인덱스 자체가 그 책의 내용과 같다.

클러스터형 인덱스는 **테이블 당 한 개**만 생성가능하며, 레코드를 인덱스로 지정한 열에 맞춰 자동으로 정렬한다.

클러스터형 인덱스는 PK를 지정한다. 따라서 **클러스터형 인덱스 == PK** 라고 생각하면 된다.

`테이블 생성 시에 UK를 지정하면 보조 인덱스가 생성된다.`

---

보통 Spring, JPA로 개발을 하다보면 기계적으로 클러스터형 인덱스(PK)를 Auto_Incremnet 옵션을 사용하곤 한다.

그런데 Bigint 타입의 해당 옵션이 아닌, UUID등과 같이 String 타입을 PK로 지정하면 어떻게 순서가 유지될까?

앞서 말했듯이 클러스터형 인덱스는 영어사전처럼 **순서대로** 정렬한다고 했다.

따라서 데이터가 삽입된 순서에 관계없이 무조건 해당 String 값으로 정렬을 해놓는다.

이래서 String 타입으로 PK를 사용하지 않는 것도 있다. 삽입을 하면 추가적으로 인덱스를 정렬해줘야 하기 때문에 여기서 리소스가 발생하기 때문이다.

## 인덱스 종류 - 보조 인덱스


## 인덱스 구조

MySQL에서는 B-Tree, HashMap으로 구조화되어있다.

B-Tree는 아래 그림과 같이 구성되어있다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/707134c7-a347-49b5-84a0-59735047524a)

루트 노드와 리프 노드가 트리 형태로 이어져 있으며 **각 노드는 16KB**인 페이지다.

B-Tree에서 **"BBBGGGYYY"** 라는 데이터를 찾는 과정은 다음과 같다. 예시는 위 그림을 들겠다.

- 루트노드에서 시작하여 BBB에 해당하는 리프 노드로 간다.
- BBB에 해당하는 리프노드에서 GGG에 해당하는 리프노드로 간다.
- GGG에 해당하는 리프노드에서 YYY를 찾는다.

**노드 == 페이지** 라고 볼 수 있으므로 위 과정은 (루트노드 + 리프노드1 + 리프노드2) 총 3개의 페이지로 찾아낼 수 있게 되었다.

만약 B-Tree로 안되어있었다면 5페이지를 읽어야할 수도 있었는데 위 구조를 통해 그 수를 줄였다.



---

# 인덱스 적용 후 성능 개선

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/3198996e-f9f8-4188-9ce8-b2cc555d0d84)

아까 **13초** 걸리던 로직이 **1.3초로 개선**되었다....

인덱스의 효과는 엄청나다!

# 인덱스 사용 시 주의할 점

- 이미 돌아가고 있는 대용량 테이블에 인덱스를 생성하면 엄청나게 시간이 소요될 수 있다.
