---

title: JPA와 Index를 친해지게 하기

date: 2023-07-07
categories: [JPA, MySQL, Index]
tags: [JPA, MySQL, Index]
layout: post
toc: true
math: true
mermaid: true

---

# 문제 상황

현재 진행하는 프로젝트에서 특정 키워드가 포함된 레코드를 모두 조회하는 요구사항이 있었다.

현재 레코드 수는 아래 그림과 같이 약 165570개 이고, 매 1시간마다 800 ~ 1200개의 레코드가 추가되는 테이블을 사용하고 있다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/b5652947-38a4-42c4-b6e6-a909d65e0b52)

위 요구사항을 해결하기 위한 로직을 처리하는데 아래와 같이 12초 ~ 13초의 시간이 소요되어 이를 개선하고자 한다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/dbd5d34f-8329-42dd-b23d-848f96bb9cc0)

---

# 문제 분석

문제의 원인이 무엇인지 살펴보기 위해 쿼리를 살펴보면 아래와 같다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/b95ff053-6f4f-4142-8e8f-f2a61098a917)

**news**라는 테이블의 모든 레코드를 Full Scan하면서 조건에 맞는 레코드를 가져오는 로직이다.

여기서 문제가 발생한 것이였다. 레코드 수가 너무 많기 때문에 A-Z까지 도달하는 시간 자체가 길어진 것이다.

이를 해결하려면 어떻게 해야할까? 내가 생각했던 해결책은 아래와 같다.

- 특정 조건에 부합하는 레코드를 포인터로 찝어서 조회를 수행한다. (커서 페이징과 유사한 해결방식)
- DB에 보조 인덱스를 생성하여 조회 시 성능을 더 높일 수 있도록한다.

---

# 해결 과정

**보조 인덱스를 어떤 컬럼을 지정해야하는가?** 를 고민하기 시작했다.

인덱싱의 원리의 따르면 보조 인덱스는 **조회할 때 사용할 조건 컬럼**이 되어야하고 **되도록 중복되지 않는 것**이 성능 개선에 더 좋다고 한다.

위 사항을 고려하여 조회할 테이블의 레코드를 살펴보면 어떤 것을 보조 인덱스로 지정할 지 결정하면된다.

## 인덱스란?

---

# 해결 후 성능 개선

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/3198996e-f9f8-4188-9ce8-b2cc555d0d84)

아까 13초 걸리던 로직이 1.3초로 개선되었다....

인덱스의 효과는 엄청나다!

# 인덱스 사용 시 주의할 점
