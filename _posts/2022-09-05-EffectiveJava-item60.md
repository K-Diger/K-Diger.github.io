---

title: Item 60. 정확한 답이 필요하다면 float와 double은 피하라

date: 2022-09-02
categories: [Effective-Java]
tags: [Float, Double, BigDecimal]
layout: post
toc: true
math: true
mermaid: true

---

# float, double

넓은 범위의 수를 빠르게 정밀한 **근사치**로 계산하도록 설계되었다.

> 즉, 근사치이기 때문에 정확한 값이아니다. 최대한 가까운 값을 보여주는 것 뿐이다.

그렇기 때문에 정확하게 계산해야하는 상황에서는 float, double을 피해야할 필요가 있다.

# 근사치값을 볼 수 있는 예시

## 1달러 3센트가 있을 때, 42센트 물건을 구매한 상황

    System.out.println(1.03 - 0.42);

위 코드를 실행한 결과는 다음과 같다.

    0.6100000000000001

우리의 수학적인 계산을 수행하면 그냥 0.61이라는게 계산될 문제인데

실제 출력을 까보면 소수점 저 아래에, 1이라는 소수점이 붙어있다.

# 근사치값을 볼 수 있는 예시 2

## 1달러가 있을 때, 10센트 짜리 물건 9개를 구매한 상황

    System.out.println(1.00 - 0.9);

위 코드를 실행한 결과는 다음과 같다.

    0.09999999999999998

---

# 근사치가 그렇게 문제인가?

아직 적절한 예시를 찾지 못했다. 하지만 그냥 상상을 해보자

어떠한 요청을 10억번을 처리한다고 해보자.

그렇게 되면 저 근사치로 인한 잘못된 소수점이 쌓이고 쌓여 결국에는 소수점이 아닌 실제 정수 부분의 값에도 영향이 끼치게 된다.

서비스 운영 중에 발생한 상황이라면 정말 치명적인 문제다.

---

# 그럼 정확하게 다루려면 어떻게 해야하는가?

### 그전에, 기존 부동소수점 표현 자료형은 소수점 표현을 어떻게 했는가?

double 타입은 기본적으로 64비트로 표현된다.

1 bits 는 양/음 수를 표현하기 위해 사용된다.
11 bits 는 지수를 표현하기 위해 사용된다.
52 bits 는 유효숫자를 표현한다. (소수는 2진수로 표현한다.)

> 소수를 2진수로 표현하는 점을 주목하라.
>
> 무한하지 않은 자릿수의 2진수의 표현 방식에는 분명히 한계가 있다. (2진수 2비트로 7을 표현할 수 있는가?)

byte, char, int, long 은 고정 소수점 숫자 이므로 소수점 표현이 불가능 했다.



### 소수점 표현에는 BigDecimal, 정수 표현에는 int, long 자료형을 활용해보자.

BigDecimal 은 속도가 다소 느리고, 기본 타입보다 사용이 불편하지만 무한에 가까운 정확성을 보여준다.

> 주의할 점. BigDecimal("10.09");
>
> 위와 같이 생성자에 문자열로 넣어줘야한다는 점을 주의해야한다.

<br>

    BigDecimal bigDecimal1 = new BigDecimal("1.009");
    BigDecimal bigDecimal1 = new BigDecimal("1.99");

<br>

BigDecimal("1.009") 가 있다면 먼저 10의 세제곱을 곱해서, 정수로 만든다.
BigDecimal("1.99") 가 있다면 먼저 10의 제곱을 곱해서, 정수로 만든다.

그 후, n제곱을 위한 n 을 저장하여 unscale(역수) 로 곱하기 위한 내용을 저장한다.

위와 같은 과정을 수행하게되면 소수점 또한 사실상 10진수로 저장하기 때문에

우리가 다루는 수의 범위에서는 모든 수를 표현할 수 있게 되는 것이다.
