---

title: OAuth란? (재도전)
author: 김도현
date: 2022-08-31
categories: [Java, Spring, Spring-Security, OAuth]
tags: [Java, Spring, Spring-Security, OAuth]
layout: post
toc: true
math: true
mermaid: true

---

# OAuth 배경

## OAuth 는 무슨 줄임말인고....

Open Authorization 직역하면, 공개 인증이라는 의미이다.

다른 웹 서비스에게 이용중인 서비스에 있는 나의 정보에 접근할 수 있는 권한을 공개하여 인증할 수 있도록 접근 위임을 통한 인증을 수행하도록한다.

라는 의미로 알고있어도 좋다.

## OAuth 1.0 의 등장

2007년 12월, OAuth 가 등장했다. 실제로 트위터 등 대형 서비스에서도 도입을 시작하였고

2008년 ~ 2010년 까지 구글에서 OAuth 1.0 을 지원해왔다.

하지만 OAuth 1.0 버전에는, 암호화 구현 및 암호화 상호 운용성이 필요했고 개발자들이 이를 구현하기에는 꽤나 어려운 작업이 요구되었다.

## OAuth 2.0 의 등장

그래서 암호화 구현을 미리 포함해놓은 OAuth 2.0 이 등장했다. 이 과정에는 많은 대기업이 OAuth 표준 을 제정하는데에 일조한 배경이 있다.

따라서 OAuth 2.0 은 더 사용하기 쉬워진 개선된 버전이라고 보면 된다.

---

## OAuth 1.0 의 특징

### 독립적인 전송방법

HTTPS/TLS 에 보안을 맡기는 방법이 아닌, 자체적인 보안 인증을 수행한다.

### 디지털 서명에 기반한 암호기반

메세지의 무결성과 신뢰성을 증명하기 위해, 디지털 서명을 수행한다.

### 메세지는 개별적으로 암호화된다.

통신 과정에서 하나의 요청에 대해 여러 메세지로 나뉠 수 있다.

이 때 각 메세지마다 암호화를 수행하여, 어느 한 메세지라도 부적절하다면 그 전체 트랜잭션은 무효화된다.

## OAuth 2.0 의 특징

### 독립적인 전송방법

OAuth 1.0과 달리 대부분의 보안 방어는 HTTPS/TLS에 위임된다.

오타, 부적절한 TLS 구성, 인증서 유효성 검사 실패 또는 기본 라이브러리의 취약점으로 인해

MitM(Man-in-the-Middle) 공격이 발생하여 모든 OAuth 통신이 손상될 수 있다.

### bearer(무기명) 토큰에 기반한다.

무기명 토큰은 통합하기 쉽지만 보안에는 좋지 않다.

무기명(bearer) 토큰은 내부 보안 메커니즘을 제공하지 않아 복사하거나 훔칠 수 있지만 구현하기가 더 쉽다.

### 쉽다.

OAuth 2.0은 훨씬 더 쉽게 사용할 수 있지만, 안전하게 빌드하기가 훨씬 더 어렵다.

### 유연하다.

OAuth 1.0 은 Web-Workflow 만 처리했지만

OAuth 2.0 은 Web 뿐만아니라 Client 또한 고려한다.

### 역할 분리

리소스 요청 처리, 사용자 권한 부여 처리

로 역할을 분리하여 사용할 수 있다.

---

# Spring Security - OAuth 배경지식

## 기본 용어

### Resource Owner

> 자원에 대한 접근을 허가해 줄 수 있는 주체

즉, Google, Kakao, Facebook 등 소셜 미디어 사용자를 가리킨다.

<br>

### Resource Server

> 자원을 호스팅하는 서버

즉, Google 서버, Kakao 서버, Facebook 서버 등 소셜 미디어의 서버를 가리킨다.

<br>

### Client

> Resource Server 에서 제공하는 자원을 사용하는 애플리케이션

Spring 이 해줄 수 있는 역할로, Google 프로필 사진을 내 DB 에 저장하는 등의 기능을 수행할 수 있다.

<br>

### Authorization Server

> 사용자(Resource Owner)의 동의를 받아서(OAuth 를 수행해서) 권한을 부여하는 서버를 가리킨다.

<br>

## OAuth Workflow

1. Client [Authorization Request] -> Resource Server
2. Resource Server [Authorization Grant] -> Client
3. Client [Authorization Grant] -> Resource Server
4. Resource Server [AccessToken] -> Client
5. Client [AccessToken] -> Resource Server
6. Resource Server [Protected Resources] -> Client

---

## Spring Security 5 이전의 OAuth

### 통합되지 않은 기능

Spring Security 4 까지는 Spring Security OAuth 라는 별도의 모듈이 존재했다.

    org.springframework.security.oauth:spring-security-oauth
    org.springframework.security.oauth:spring-security-oauth2

OAuth 1.0, OAuth 2.0 모두 지원했으며, OAuth Client, Resource Server, Authorization Server 를 지원했다.

<br>

### 손수 만들어줘야하는 기능

### Client

    @EnableOAuthClient
    OAuth2ClientContextFilter, OAuth2ClientAuthenticationProcessingFilter, OAuth2ProtectedResourceDetails, OAuth2RestTemplate

@EnableOAuthClient 어노테이션을 붙여, 클라이언트에 해당하는 위 네가지 항목을 모두 구현해줘야했다.

<br>

### ResourceServer

    @EnableResourceServer
    TokenStore, ResourceServerTokenService

@EnableResourceServer 어노테이션을 붙여, 리소스 서버에 해당하는 위 두 항목을 모두 구현해줘야했다.

<br>

### AuthorizationServer

    @FrameworkEndpoint
    AuthorizationEndpoint, TokenEndpoint, CheckTokenEndpoint ...

@FrameworkEndpoint 어노테이션을 붙여, 인증 서버에 해당하는 여러 항목을 모두 구현해줘야했다.

---

## Spring Security 5에서의 OAuth

OAuth Client -> 5.0 Release

Resource Server -> 5.2 Release

Authorization Server -> ...X

<br>

어쩌다가 Authorization Server 는 Spring Security 에서 제공하지 않게 되었다.

그래서 결국 Spring 자체에서, Spring-Authorization Server 를 출시했다.

---

# Spring Security - OAuth Setting

## 0. Spring Boot Application 에서 Client - 최소 설정 사용

잘 알려진 Google, GitHub, Facebook, Okta 와 같은 Provider 를 사용할 경우, 아래와 같은 형식을 명시해 놓으면된다.

### application.yml

    spring:
        security:
            oauth2:
                client:
                    registration:
                        google:
                            client-id: google-client-id
                            client-secret: google-client-secret

### Spring Boot 에서 OAuth 최소 설정을 사용했을 때의 주의할 점

OAuth2AuthorizedClientService 라는 Bean 이 있는데, 이 기본 구현이 In Memory로 구현되어있다.

OAuth2AuthorizedClient : Resource Owner 가 Authorization grant 를 해준 Client 정보를 추상화한다.

OAuth2AuthorizedClientService : OAuth2AuthorizedClient 관리 기능 제공(load/save/remove)

> 사용자가 로그인을 하며 OAuth 기능을 수행할 때마다, 메모리에 클라이언트 정보가 남게되어 나중에는 메모리 초과(OOM)가 발생하게 될 것이다.
>
> 실제 서비스를 위한 애플리케이션이라면, 다른 구현체를 사용해야한다.

---

## 1. Spring Boot Application 에서 Client - 최소 설정 + 추가 셋팅

    @Configuration
    public class SecurityConfig extends WebSecurityConfigAdapter {

        @Override
        protected void configure (HttpSecurity http) thorws Exception {
            http
                // OAuth Client 를 사용하는 메서드
                .oauth2Login()

                // 최소설정에서, application.yml 에 등록하던 내용으로 Provider를 등록한다.
                // In Memory로 사용해도 무관하다. (Provider가 몇 개 안되기 때문)
                .clientRegistrationRepository(clientRegistrationRepository())

                // 인증 정보를 DB에 저장하기 위한 메서드
                // 애플리케이션에서 사용하는 Repository를 사용한다. (UserRepository, PostRepository 등...)
                .authorizedClientService(authorizedClientService());

                .authorizationEndpoint()
                    // 인증 요청 시 추가적인 파라미터를 전달
                    .authorizationRequestResolver(authorizationRequestResolver())
                    .and()
                .redirectionEndpoint()
                    // 인증 응답이 처리될 URI 지정
                    .baseUri("/login/oauth2/callback/*")
                    .and()
                .tokenEndpoint()
                    .accessTokenResponseClient(this.accessTokenResponseClient())
                    .and()
                userInfoEndpoint()
                    // UserInfo 에 대한 요청/응답 커스터마이징
                    .userService(oauth2UserService())
                    // UserInfo 응답 커스터마이징
                    .customUserType(GoogleOAuthUser.class "google")

        }
    }

---

## 참고자료 및 부연설명

[Spring Security 공식 문서](https://docs.spring.io/spring-security/site/docs/5.0.7.RELEASE/reference/html/oauth2login-advanced.html#oauth2login-advanced-userinfo-endpoint)

[예시 코드](https://theheydaze.tistory.com/477)

<br>

### authorizationEndpoint

#### OAuth2LoginSecurityConfig.java

    @EnableWebSecurity
    public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .oauth2Login()
                    .authorizationEndpoint()
                        .authorizationRequestRepository(this.cookieAuthorizationRequestRepository())
                        ...
        }

        private AuthorizationRequestRepository<OAuth2AuthorizationRequest> cookieAuthorizationRequestRepository() {
            return new HttpCookieOAuth2AuthorizationRequestRepository();
        }
    }

인증을 수행하는 엔드포인트(지점)이다. 인증에 있어서 추가적인 파라미터를 활용할 수 있게하는 설정이다.

쿠키에 OAuth2AuthorizationRequest의 속성을 저장하는 AuthorizationRequestRepository의 구현체를 제공하려면 위와 같은 형태를 활용하면된다.

아래는 HttpCookieOAuth2AuthorizationRequestRepository 의 본체 예시이다.

#### HttpCookieOAuth2AuthorizationRequestRepository.java
    @Component
    public class HttpCookieOAuth2AuthorizationRequestRepository implements AuthorizationRequestRepository<OAuth2AuthorizationRequest> {

        public static final String OAUTH2_AUTHORIZATION_REQUEST_COOKIE_NAME = "oauth2_auth_request";
        public static final String REDIRECT_URI_PARAM_COOKIE_NAME = "redirect_uri";
        private static final int cookieExpireSeconds = 180;

        // cookie 에 저장되어있던 authorizationRequest 들을 가져온다.
        // authorizationUri, authorizationGrantType, responseType, clientId, redirectUri, scopes, additionalParameters

        @Override
        public OAuth2AuthorizationRequest loadAuthorizationRequest(HttpServletRequest request) {
            return CookieUtils.getCookie(request, OAUTH2_AUTHORIZATION_REQUEST_COOKIE_NAME)
                    .map(cookie -> CookieUtils.deserialize(cookie, OAuth2AuthorizationRequest.class))
                    .orElse(null);
        }

        // 플랫폼으로 보내기 위한 Request 를 `oauth2_auth_request` 라는 cookie 에 저장 한다.
        // authorizationUri, authorizationGrantType, responseType, clientId, redirectUri, scopes, additionalParameters
        @Override
        public void saveAuthorizationRequest(OAuth2AuthorizationRequest authorizationRequest, HttpServletRequest request, HttpServletResponse response) {
            if (authorizationRequest == null) {
                removeAuthorizationRequest(request, response);
                return;
            }

            CookieUtils.addCookie(response, OAUTH2_AUTHORIZATION_REQUEST_COOKIE_NAME, CookieUtils.serialize(authorizationRequest), cookieExpireSeconds);

            // http://localhost:8080/oauth2/authorize/naver?redirect_uri=http://localhost:3000/oauth/redirect 로 요청 받았을 때
            // http://localhost:3000/oauth/redirect 를 가져온다.
            // 그리고 존재하는 경우 cookie 에 넣어준다

            String redirectUriAfterLogin = request.getParameter(REDIRECT_URI_PARAM_COOKIE_NAME);

            if (StringUtils.isNotBlank(redirectUriAfterLogin)) {
                CookieUtils.addCookie(response, REDIRECT_URI_PARAM_COOKIE_NAME, redirectUriAfterLogin, cookieExpireSeconds);
            }
        }

        // remove 를 재정의 해서 cookie 를 가져오고 remove 는 successHandler 또는 failureHandler 에서 할 수 있도록 한다.
        @Override
        public OAuth2AuthorizationRequest removeAuthorizationRequest(HttpServletRequest request) {
            return this.loadAuthorizationRequest(request);
        }

        // 사용자 정보를 다 가지고 온 뒤 이제 리다이렉트를 하면 기존에 남아있던 쿠키들을 제거해주기 위해 사용된다
        // OAuth2AuthorizationRequest 와 클라이언트에서 파리미터로 요청한 redirect_uri 가 된다

        public void removeAuthorizationRequestCookies(HttpServletRequest request, HttpServletResponse response) {
            CookieUtils.deleteCookie(request, response, OAUTH2_AUTHORIZATION_REQUEST_COOKIE_NAME);
            CookieUtils.deleteCookie(request, response, REDIRECT_URI_PARAM_COOKIE_NAME);
        }
    }

<br>

### redirectionEndpoint

#### OAuth2LoginSecurityConfig.java

    @EnableWebSecurity
    public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .oauth2Login()
                    .redirectionEndpoint()
                        .baseUri("/login/oauth2/callback/*")
                        ....
        }
    }

인증이 끝나면 리다이렉션 해줄 URI 를 말한다.

<br>

### tokenEndpoint

#### OAuth2LoginSecurityConfig.java

    @EnableWebSecurity
    public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .oauth2Login()
                    .tokenEndpoint()
                        .accessTokenResponseClient(this.accessTokenResponseClient())
                        ...
        }

        private OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> accessTokenResponseClient() {
            return new SpringWebClientAuthorizationCodeTokenResponseClient();
        }
    }

인증이 끝나고, 사용자에게 JWT 를 넘겨줄 때 이 역할을 수행할 엔드포인트(지점)이다.

### userInfoEndpoint

#### OAuth2LoginSecurityConfig.java

    @EnableWebSecurity
    public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .oauth2Login()
                    .userInfoEndpoint()
                        .customUserType(GitHubOAuth2User.class, "github")
                        ...
        }
    }

#### GitHubOAuth2User.java

    public class GitHubOAuth2User implements OAuth2User {
        private List<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList("ROLE_USER");
        private Map<String, Object> attributes;
        private String id;
        private String name;
        private String login;
        private String email;

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            return this.authorities;
        }

        @Override
        public Map<String, Object> getAttributes() {
            if (this.attributes == null) {
                this.attributes = new HashMap<>();
                this.attributes.put("id", this.getId());
                this.attributes.put("name", this.getName());
                this.attributes.put("login", this.getLogin());
                this.attributes.put("email", this.getEmail());
            }
            return attributes;
        }

        public String getId() {
            return this.id;
        }

        public void setId(String id) {
            this.id = id;
        }

        @Override
        public String getName() {
            return this.name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getLogin() {
            return this.login;
        }

        public void setLogin(String login) {
            this.login = login;
        }

        public String getEmail() {
            return this.email;
        }

        public void setEmail(String email) {
            this.email = email;
        }
    }
