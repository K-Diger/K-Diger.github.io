---

title: Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라
author: 김도현
date: 2023-01-17
categories: [Effective-Java]
tags: [Object]
math: true
mermaid: true

---

# 정적 메서드와 정적 필드만을 담은 클래스를 사용하고 싶을 때

위의 유형이 객체지향적인 구성은 아니다. 하지만 분명히 쓰임새가 있기 마련이다.

그 예시로 Arrays 라이브러리를 살펴보면, Arrays.toString() 등 처럼 실제 Java 공식 라이브러리에서도 위와 같은 구성을 취하곤 한다.

그리고 Collections 처럼 특정 인터페이스를 구현하는 객체를 생성하는 정적 메서드 혹은 팩터리를 모아 놓을 수 도 있다.

final 클래스와 관련한 메서드들을 모아놓을 때도 사용한다. final 클래스를 상송하여 하위 클래스에 메서드에 넣는 건 불가능하기 때문이다.

# 정적 멤버만 담은 클래스는 유틸리티 클래스이다.

인스턴스화 하여 사용할 목적으로 설계된 것이 아니므로 인스턴스화를 막아야할 필요가 있다.

하지만 생성자를 따로 명시하지 않으면 매개변수가 없는 public 생성자가 자동으로 만들어져 이를 막아야지 목적에 맞게 사용할 수 있다.

# 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.

추상클래스를 상속받는 하위클래스를 만들어 인스턴스화 하는 방법이 가능하기 때문에 인스턴스화를 방지할 수 없다.

또한 추상클래스를 만들어 놓으면, 사용자는 이를 상속해서 사용하라는 의미로 받아들일 수 있기 때문에 주의해야한다.

# 인스턴스화를 막는 방법은 private 생성자를 만드는 것

```java
public class UtilClass {

    private UtilClass() {
        throw new AssertionError();
    }
}

```
위와 같이 인스턴스화를 막기 위해서는 private 생성자를 꼭 명시해줘야함을 잊지 말자.

또한 클래스 자체에서 생성자를 호출하는 것을 막기 위해 예외를 던지는 것도 좋은 방법이다.

이렇게 생성자를 private으로 하면 상속을 불가능하게도 한다.

모든 생성자는 명시적/묵시적으로 상위 클래스의 생성자를 호출하는데 이를 private으로 했으니 하위 클래스가 상위 클래스의 생성자에 접근하지 못하기 때문이다.
