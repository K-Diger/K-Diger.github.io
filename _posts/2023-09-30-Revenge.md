---

title: 기본이 중요하다
date: 2023-09-30
categories: []
tags: []
layout: post
toc: true
math: true
mermaid: true

---

# Resume, Portfolio

## SUWIKI

### 강의평가 작성 시 비관적 락을 활용한 동시성 문제를 해결한 구체적인 상황

A라는 강의 레코드에 X, Y 가 각각 값을 올리고 내리는 요청이 동시에 발생했다.

레코드의 값을 증가시키기위 위해 SELECT 하는 구문과, 값을 감소시키기 위해 SELECT 하는 구문이 동시에 발생했고

커밋되는 시점이 달라 값을 증가시킨 요청이 커밋되었음에도 값을 감소시키는 요청이 커밋되어 변경사항을 덮어 씌우는 현상이 발생했다.

동시성 문제를 해결하는 방법을 알아보는 중 DBMS에서 충돌이 발생하지 않는 상황을 가정하여 애플리케이션 단위에서 동시성을 처리하는 낙관적 락과 DBMS에서 충돌이 발생하는 상황을 가정하는 비관적 락의 차이를 학습하고 비관적 락을 적용하여 해결하기로 결정했다.

이 방법을 적용하게 된 근거로는 각 방식의 장/단점을 따져보았는데

낙관적 락의 장/단점으로는

- 실제로 Lock을 거는 것이 아니기 때문에 성능저하의 우려가 없다.
- 하지만 충돌이 발생해서 롤백을 해야하는 경우 수동으로 해당 데이터의 내용을 모두 롤백하는 로직을 만들어야해서 복잡해질 수 있다.

비관적 락의 장/단점으로는

- Lock을 통해 데이터의 무결성을 보장할 수 있다. 그리고 그럼에도 충돌이 발생했을 경우에는 롤백연산을 한 번만 수행해도 된다.
- 하지만 Lock을 거는 것으로 인한 리소스 경쟁으로 성능 저하가 발생할 수 있다.

그리고 비관적 락에도 종류가 있는데

특정 레코드에 접근했을 때 다른 트랜잭션에서 읽기만 가능하게 하는 `공유 락`, 읽기 및 쓰기 모두 불가능한 `베타 락`이라는 종류가 있다.

이 차이점을 알아본 후 JPA가 지원하는 `@Lock`애노테이션의 `PessimisticRead`옵션으로 해당 문제를 해결했다.

---

## SUGO

### @Asnyc 애노테이션을 사용하여 81% 성능 개선

#### 문제 상황

클라이언트에 푸쉬 알림을 전송하기 위해 FCM 서버에 요청하는 로직을 추가했더니 아래와 같이 658ms가 소요되는 현상이 발생했다.

![](https://github.com/K-Diger/K-Diger.github.io/blob/main/images/async/%EC%84%B1%EB%8A%A5%20%EA%B0%9C%EC%84%A0%20%EC%9D%B4%EC%A0%84%20%EB%91%90%EB%B2%88%EC%A7%B8%20%EC%9A%94%EC%B2%AD.jpg?raw=true)

이 메서드를 추가하기 전에는 100ms도 넘지 않았던 응답시간이 저렇게 급격하게 늘어나니 클라이언트단에서도 응답을 기다리느라 사용자 경험을 해치는 상황이 발생하게 되었다.

#### 어떻게 속도를 빠르게 할 수 있을까?

외부 서버를 호출하는 로직을 비동기로 처리하면 어떨까? 굳이 외부 서버로 던진 요청이 완료된 것을 확인받은 후에 다른 비즈니스 로직을 처리해야할까? 를 고민하다가 직접 비동기 메서드를 적용해보기로 했다.

`Spring boot Async Processing`이라고 검색하면 가장 많이 나오는 내용이 `ThreadPoolTaskExecutor`에 관한 내용이 등장한다.

#### ThreadPoolTaskExecutor와 @Async

[Asynchronous calls in spring](https://www.linkedin.com/pulse/asynchronous-calls-spring-boot-using-async-annotation-omar-ismail/)

Spring에서 비동기 작업을 처리하려면 다음 두 가지를 관리해야한다.

- @Asnyc 애노테이션으로 비동기 메서드를 지정한다.
- 비동기 메서드의 처리를 담당하는 스레드 풀을 관리해줘야한다.

스레드 풀을 관리하기 위한 Bean을 등록하기 위해서는 아래의 인터페이스의 구현체를 셋팅해줘야 한다.

```java
public interface AsyncConfigurer {

	/**
	 * The {@link Executor} instance to be used when processing async
	 * method invocations.
	 */
	@Nullable
	default Executor getAsyncExecutor() {
		return null;
	}

	/**
	 * The {@link AsyncUncaughtExceptionHandler} instance to be used
	 * when an exception is thrown during an asynchronous method execution
	 * with {@code void} return type.
	 */
	@Nullable
	default AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
		return null;
	}

}
```

하지만 꼭 위 인터페이스를 구현체로 등록하지 않아도 되긴하다. 그냥 ThreadPoolTaskExecutor를 반환하는 메서드를 Bean으로 등록해주면 되는 것일 뿐이다.

#### @Async 애노테이션이 어떻게 동작하는건가?

- @Async 애노테이션이 붙은 메서드가 실행될 때, 프록시가 해당 호출을 가로채고 Task Executor에 전달한다.

- Task Executor는 새로운 스레드를 생성하고 해당 스레드에서 호출된 로직을 실행한다. 그리고 이 때 이 메서드의 리턴을 기다리지 않고 다른 작업을 계속 수행한다.

- 이전에 호출시킨 메서드가 리턴되었다면 Task Executor에 결과를 반환한다.

이 때 새로운 스레드를 생성한다는 점이 성능 저하의 문제가 될 수 있다.

```java
public class ThreadPoolTaskExecutor extends ExecutorConfigurationSupport
		implements AsyncListenableTaskExecutor, SchedulingTaskExecutor {

    private final Object poolSizeMonitor = new Object();

    private int corePoolSize = 1;

    private int maxPoolSize = Integer.MAX_VALUE;

    private int keepAliveSeconds = 60;

    private int queueCapacity = Integer.MAX_VALUE;

    private boolean allowCoreThreadTimeOut = false;

    private boolean prestartAllCoreThreads = false;

    ...
}
```
위 코드가 Spring이 관리하는 스레드 풀인 ThreadPoolTaskExecutor이다.

해당 클래스의 프로퍼티를 보면,

- `corePoolSize` : 초기 Thread Size는 1

- `maxPoolSize` : 최대 Thread Pool Size는 약 21억

- `queueCapacity` : Queue 용량은 약 21억

으로 설정되어있다. 위 설정을 그대로 사용해도 좋지만 애플리케이션 환경과 서버의 하드웨어 스펙에 따라 조정해 줄 필요는 있을 것 같다.

---

#### 다시 돌아와서, 뭐가 문제였나?

- @Asnyc 애노테이션을 활용하여 비동기 메서드를 지정하지 않았던 점

- ThreadPoolTaskExecutor와 같이 스레드 풀을 관리해주는 설정을 Bean으로 등록하지 않은 점

이 두 가지를 적용하지 않았기 때문에 응답에 지연이 생긴 것으로 볼 수 있다.

#### 해결 방안 및 성능 개선 결과

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(3);
        executor.setMaxPoolSize(30);
        executor.setQueueCapacity(90);
        executor.setThreadNamePrefix("SUGO-DIGER-ASYNC-");
        executor.initialize();

        return executor;
    }
}
```

위와 같은 설정을 Bean으로 등록해주고 비동기로 처리할 메서드에 `@Async`애노테이션을 붙여주면 끝이다! 이렇게 간단하게 해결할 수 있음에도 성능 차이는 엄청났다.

![](https://github.com/K-Diger/K-Diger.github.io/blob/main/images/async/%EC%84%B1%EB%8A%A5%20%EA%B0%9C%EC%84%A0%20%ED%9B%84%20%EB%91%90%EB%B2%88%EC%A7%B8%20%EC%9A%94%EC%B2%AD.jpg?raw=true)

- 응답 시간 `658ms` -> `122ms` 응답 시간이 81% 빨라졌다.

#### @Async 애노테이션을 사용할 때 기억해둬야할 것

##### 1. 쓰레드와 큐의 사이즈를 지정할 때 신중해야한다.

여기서 다루는 쓰레드는 `논리적인 쓰레드를`말한다.

쓰레드를 생성하는 비용은 꽤나 엄청난 작업이다. 그렇기 때문에 아래 속성을 정의할 때 주의해야한다.

주로 실제 부하 테스트를 통해 측정해보면 정확하게 지정할 수 있겠으나 나는 그 부분까지는 수행하진 못했다.

아래 속성들은 비동기 처리를 위한 추가적으로 생성할 리소스를 의미한다.

`기본값`은 다음과 같이 설정되어있다.

- `corePoolSize` : 최소 비동기 쓰레드 수 : 1

- `maxPoolSize` : 최대 비동기 쓰레드 수 : 약 21억

- `queueCapacity` : queueCapacity는 작업 큐의 사이즈 : 약 21억

---

##### 1.1. 각 속성이 어떻게 쓰이는 거지?

- 새로운 쓰레드를 생성하는 것은 리소스가 크기 때문에 일반적으로는 쓰레드 풀을 사용한다.
- 초기 쓰레드 갯수를 10개로 지정했고, 최대 쓰레드 갯수를 100개로 했을 때
    - 50개의 요청이 동시에 들어오면 쓰레드 갯수는 몇 개가 될 것인가?
        - 우선 10개로 처리를 한 후 쓰레드가 잡지 못한 요청은 우선적으로 Queue에 쌓인다.

- 큐 사이즈가 꽉차면 어떻게 될까?
    - 큐 사이즈가 꽉찬다면 큐에 있는 작업을 처리할 쓰레드를 추가로 늘린다.
        - 이 때 쓰레드의 갯수마저도 이전에 지정한 최대치에 도달한다면 그 이후의 요청은 예외가 발생하게 될 것이다.

- 방금 말한 상황에서 발생하는 예외는 어떻게 처리해야하는가?
    - 재시도를 통해 서버에 들어온 요청을 책임지고 마쳐야 한다.

- 재시도를 했음에도 예외가 계속 발생하면요?
    - 그런 상황에서는 요청값이 잘못되거나 메서드의 로직 자체가 잘못되어있을 가능성이 있을 것이기 때문에
    - 그때는 비동기 메서드에 대한 검증을 다시 해봐야한다.

- 큐의 작업을 처리하기 위해 쓰레드를 늘렸을 때 그 쓰레드들은 계속 유지되는가?
    - 아니다. 사용되지 않는 쓰레드들은 일정 시간이 지나면 유휴 상태에 들어가 반납되는 것으로 공식문서에 명시되어있다.

##### 2. @Async가 달린 비동기 메서드는 반환 값이 없어야한다.

당연하게도 비동기로 처리할 로직에는 반환 값이 없어야한다.

반환 값이 있다는 것은 그 모든 리소스를 반환할 때 까지 다음 메서드를 수행하지 못하기 때문에 당연히 비동기 작업에는 반환값이 없어야 하는 것이다.

만약 언젠가 처리가 끝나고나서 그 반환값을 사용하고자 한다면 `CompetableFuture`타입으로 반환해야한다.

##### 3. @Async가 달린 비동기 메서드는 private하면 안된다.

[참고자료 - 왜 @Async 애노테이션이 달린 메서드는 private하면 안되나?](https://dzone.com/articles/effective-advice-on-spring-async-part-1)

@Async 애노테이션은 AOP기반으로 동작한다. 따라서 해당 애노테이션이 붙은 메서드를 감싸는 프록시 객체를 생성하는 것인데

이 프록시 객체는 실제 비동기 작업을 처리할 때 사용된다. 프록시 객체로 동작한다는 것이 그 이유이다.

---

#### 비동기로 요청한 내용이 실패했다면 어떻게 되는건가?

지금 로직은 비즈니스 로직을 처리하고 비동기로 외부 서버를 호출한 후 곧바로 리턴하여 클라이언트에게 결과를 전송한다.

그런데 만약 비동기로 외부 서버호출한 내용이 실패한다면 어떻게 되는걸까?

- 재시도를 통해 책임지고 끝낼 수 있도록 한다.
- 예외 처리를 한다.
  - 하지만 이 방법은 아직 잘 모르겠다. 예외처리를 하기 위해선 결국 외부 서버로부터 응답을 받아야하는데, 이 응답을 기다리는 것이 동기로 통신하는 것과 다를 바 없기 때문이다.



---

## SHORTS

### 인덱스를 통해 150만건이 담긴 데이터베이스 내 BETWEEN 조건 질의시 성능 개선

현재 레코드 수는 아래 그림과 같이 약 160만개 이고, 매 1시간마다 800 ~ 1200개의 레코드가 추가되는 테이블을 사용하고 있다.

![img.png](https://github.com/K-Diger/K-Diger.github.io/blob/main/images/index/img.png?raw=true)

위 요구사항을 해결하기 위한 로직을 처리하는데 아래와 같이 12초 ~ 13초의 시간이 소요되어 이를 개선하고자 한다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/dbd5d34f-8329-42dd-b23d-848f96bb9cc0)

#### Index를 적용하지 않았을 때의 실행 계획

```mysql
EXPLAIN ANALYZE
SELECT *
FROM news
WHERE created_at BETWEEN '2023-07-07 10:00:00' AND '2023-07-07 11:00:00' AND title LIKE '%입력값%';
```

위와 같은 쿼리를 날렸을 때의 결과는 아래와 같다.

```text
(news.created_at between '2023-07-07 10:00:00' and '2023-07-07 11:00:00')
(cost=83282.06 rows=26888) (actual time=7404.655..19644.905 rows=2027 loops=1)
-> Table scan on news  (cost=83282.06 rows=242017) (actual time=5.829..19139.414 rows=305977 loops=1)
```

인덱스를 적용하지 않았을 땐 5.8초 ~ 19139.414 초가 걸릴 수 있다.

#### Index를 적용한 후 실행 계획

```text
with index condition: (news.created_at between '2023-07-07 10:00:00' and '2023-07-07 11:00:00')
(cost=2088.81 rows=2027) (actual time=2.678..57.552 rows=2027 loops=1)
```

인덱스를 적용했을 땐 2.678초 ~ 57.552 초가 걸릴 수 있다고 한다.

가장 빠르게 쿼리된 상황에만 보더라도 약 50%가 성능 개선된 것으로 볼 수 있다.

그럼 인덱스를 쓰는게 무작정 좋은 것인지는 조금 더 따져봐야한다.

#### 우선 모든 컬럼을 인덱스로 잡게된다면 어떻게 될까?

- 만약 컬럼이 50가지 100가지 등등 많은 데이터를 보유하고 있다면 매 레코드를 추가할 때 마다 해당 컬럼에 대한 인덱스를 모두 추가하는 부가적인 리소스가 발생하게 되어 데이터 삽입이 매우 느리게 될 수 있다.
  - 인덱스의 내부 구현이 LinkedList와 유사한 B-Tree방식으로 구현되어있기 때문이다.
    - 책의 내용이 1000페이지인데 500페이지 쯤에서 내용을 추가해야한다고 해보자
    - 이 상황에선 당연하게도 페이지의 내용을 추가하는 것과 더불어 인덱스를 관리하는 목차 또한 모두 고쳐야한다.
  - 따라서 삽입/변경/삭제 등이 자주 일어나는 테이블에는 적절한 방법이 아니다.

- DBMS에도 인덱스를 관리하기 위한 추가적인 저장공간 리소스가 소모된다.
  - 인덱스는 일반적으로 10% ~ 20%의 공간을 추가로 요구한다.

결론적으로 인덱스는 대용량 테이블에 적용한다면 성능 개선을 기대할 수 있지만

그렇지 않다면 오히려 리소스를 더 사용하고, 조회 성능 까지도 느리게 만들 수 있다.

#### Index의 구조

MySQL에서는 B-Tree(Balanced-Tree), HashMap으로 구조화되어있다. DBMS의 종류에 따라 다르겠지만 최근에는 Fractal-Tree과 로그 기반의 Merge-Tree으로 구조화 되는 경우도 있다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/f5eb44b9-6493-4795-90ef-024d42268183)

루트 노드, 브랜치 노드, 리프 노드가 트리 형태로 이어져 있으며 각 노드는 16KB인 페이지다.

리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소를 가지고 있다.

#### Index 노드 삽입 과정

저장될 키 값을 이용해 B-Tree에 적절한 삽입점을 검색한다.

저장 위치가 결정되면 레코드의 키 값과 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.

리프 노드가 꽉 차서 저장할 수 없을 때는 리프 노드가 분리 되어야 한다. 그리고 이 때 상위 브랜치 노드까지 처리 범위가 넓어진다.

위 이유로 인해 B-Tree는 상대적으로 쓰기 작업(새로운 키 추가)에 비용이 많이 든다.

#### 인덱스를 지정할 때 고려해야할 점 - Cardinality

Cardinality, Selectivity 두 용어는 거의 같은 의미로 사용되고, `모든 인덱스 Key 값 중 유니크한 값의 수`를 말한다.

인덱스 키 값 중 중복된 값이 많아지면 많아질수록 Cardinality는 낮아진다.

인덱스는 Cardinality가 높을수록 검색 대상이 줄어들기 때문에 빠른 성능을 나타낼 수 있다.

하지만 Cardinality가 낮더라도 정렬, 그룹화 등을 위해 인덱스를 만드는 것이 더 나을 수도 있다.

인덱스는 항상 검색에만 사용되는 것이 아닌 것을 인지해야한다.

또한 [여러 컬럼을 Index로 지정할 때는 카디널리가 높은 순으로 인덱스를 생성하는 것이 더 효율적이다.](https://jojoldu.tistory.com/243)

---

# JVM Language

## JVM에서의 `autoboxing`이란 어떤 현상을 말하는 걸까?

## `interface default implementation`이란? `abstract class`를 상속받는 것과 기본 구현을 들고 있는 `interface`를 `implements`하는 것은 어떤 차이가 있나?

## `Java stream method`중 `map` 과 `flatMap` 의 차이는 무엇인가?

---

# JVM Architecture

---

# OOP/Design Pattern

---

# Test

---

# Spring

---

# JPA

---

# DBMS

---

# Cache

---
