---

title: 기본이 중요하다 (프로젝트를 진행하며 고민한 내용의 모든 것)
date: 2023-09-30
categories: [Java, Kotlin, SpringBoot, JPA, QueryDSL, MySQL, Lock, Index, Cache, Async, Test, Authorization]
tags: [Java, Kotlin, SpringBoot, JPA, QueryDSL, MySQL, Index, Cache, Test, Authorization]
layout: post
toc: true
math: true
mermaid: true

---

# SUWIKI

## 1. 강의평가 작성 시 비관적 락을 활용한 동시성 문제를 해결

[해결 과정](https://k-diger.github.io/posts/SUWIKI-1)

---

## 2. JWT를 활용한 토큰 기반 인증 vs 세션 기반 인증

[해결 과정](https://k-diger.github.io/posts/SUWIKI-2)

---

## 3. 테스트 환경 개선 및 테스트 대역을 코드로 알아보기

[해결 과정](https://k-diger.github.io/posts/SUWIKI-3)

---

## 4. Caffeine Cache를 활용하여 홈 API 응답시간 개선

[해결 과정](https://k-diger.github.io/posts/SUWIKI-4)

---

# SUGO

## 1. @Async 애노테이션을 사용하여 외부 서버 호출 시 81% 성능 개선

[해결 과정](https://k-diger.github.io/posts/SUGO-1)

---

## 2. S3에 정적 컨텐츠 업로드

---

## 3. QueryProjection을 활용하여 N + 1 문제 예방으로 조회 성능 최적화

- N+1 문제가 발생하는 이유

- N+1 문제를 해결하는 다른 방법들

- Fetch Join사용 시 주의할 점

---

## 4. Spring Security를 활용하여 사용자 인증/인가 프로세스 개선



---

# SHORTS

## 1. 크롤러 구현 및 문제 해결, 크롤링 시 OOM문제 해결 (JVM튜닝), 커넥션 부족 문제 해결

[해결 과정](https://k-diger.github.io/posts/SHORTS-1)

## 2. 키워드 추출 로직 구현

[해결 과정](https://k-diger.github.io/posts/SHORTS-2)

## 3. AOP를 활용하여 사용자 인증/인가 로직 간소화

## 4. 인덱스를 통해 150만건이 담긴 데이터베이스 내 BETWEEN 조건 질의시 성능 개선

현재 레코드 수는 아래 그림과 같이 약 150만개 이고, 매 1시간마다 800 ~ 1200개의 레코드가 추가되는 테이블을 사용하고 있다.

![img.png](https://github.com/K-Diger/K-Diger.github.io/blob/main/images/index/img.png?raw=true)

위 요구사항을 해결하기 위한 로직을 처리하는데 아래와 같이 12초 ~ 13초의 시간이 소요되어 이를 개선하고자 한다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/dbd5d34f-8329-42dd-b23d-848f96bb9cc0)

### Index를 적용하지 않았을 때의 실행 계획

```mysql
EXPLAIN ANALYZE
SELECT *
FROM news
WHERE created_at BETWEEN '2023-07-07 10:00:00' AND '2023-07-07 11:00:00' AND title LIKE '%입력값%';
```

위와 같은 쿼리를 날렸을 때의 결과는 아래와 같다.

```text
Table scan on news: (news.created_at between '2023-07-07 10:00:00' and '2023-07-07 11:00:00')
(cost=83282.06 rows=242017) (actual time=5.829..19139.414 rows=305977 loops=1)
```

인덱스를 적용하지 않았을 땐 5.8초 ~ 19139.414 초가 걸릴 수 있다.

### Index를 적용한 후 실행 계획

```text
with index condition: (news.created_at between '2023-07-07 10:00:00' and '2023-07-07 11:00:00')
(cost=2088.81 rows=2027) (actual time=2.678..57.552 rows=2027 loops=1)
```

인덱스를 적용했을 땐 2.678초 ~ 57.552 초가 걸릴 수 있다고 한다.

가장 빠르게 쿼리된 상황에만 보더라도 약 50%가 성능 개선된 것으로 볼 수 있다.

그럼 인덱스를 쓰는게 무작정 좋은 것인지는 조금 더 따져봐야한다.

### Index의 구조

MySQL에서는 B-Tree(Balanced-Tree), HashMap으로 구조화되어있다. DBMS의 종류에 따라 다르겠지만 최근에는 Fractal-Tree과 로그 기반의 Merge-Tree으로 구조화 되는 경우도 있다.

![](https://github.com/K-Diger/K-Diger.github.io/assets/60564431/f5eb44b9-6493-4795-90ef-024d42268183)

루트 노드, 브랜치 노드, 리프 노드가 트리 형태로 이어져 있으며 각 노드는 16KB인 페이지다.

리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소를 가지고 있다.

### Index 노드 삽입 과정

저장될 키 값을 이용해 B-Tree에 적절한 삽입점을 검색한다.

저장 위치가 결정되면 레코드의 키 값과 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.

리프 노드가 꽉 차서 저장할 수 없을 때는 리프 노드가 분리 되어야 한다. 그리고 이 때 상위 브랜치 노드까지 처리 범위가 넓어진다.

위 이유로 인해 B-Tree는 상대적으로 쓰기 작업(새로운 키 추가)에 비용이 많이 든다.

### 인덱스를 지정할 때 고려해야할 점 - 인덱스의 자격

- 만약 컬럼이 50가지 100가지 등등 많은 데이터를 보유하고 있다면 매 레코드를 추가할 때 마다 해당 컬럼에 대한 인덱스를 모두 추가하는 부가적인 리소스가 발생하게 되어 데이터 삽입이 매우 느리게 될 수 있다.
    - 인덱스의 내부 구현이 LinkedList와 유사한 B-Tree방식으로 구현되어있기 때문이다.
      - 책의 내용이 1000페이지인데 500페이지 쯤에서 내용을 추가해야한다고 해보자
      - 이 상황에선 당연하게도 페이지의 내용을 추가하는 것과 더불어 인덱스를 관리하는 목차 또한 모두 고쳐야한다.
    - 따라서 삽입/변경/삭제 등이 자주 일어나는 테이블에는 적절한 방법이 아니다.

- DBMS에도 인덱스를 관리하기 위한 추가적인 저장공간 리소스가 소모된다.
    - 인덱스는 일반적으로 10% ~ 20%의 공간을 추가로 요구한다.

결론적으로 인덱스는 대용량 테이블에 적용한다면 성능 개선을 기대할 수 있지만

그렇지 않다면 오히려 리소스를 더 사용하고, 조회 성능 까지도 느리게 만들 수 있다.

### 인덱스를 지정할 때 고려해야할 점 - Cardinality

Cardinality, Selectivity 두 용어는 거의 같은 의미로 사용되고, `모든 인덱스 Key 값 중 유니크한 값의 수`를 말한다.

인덱스 키 값 중 중복된 값이 많아지면 많아질수록 Cardinality는 낮아진다.

인덱스는 Cardinality가 높을수록 검색 대상이 줄어들기 때문에 빠른 성능을 나타낼 수 있다.

하지만 Cardinality가 낮더라도 정렬, 그룹화 등을 위해 인덱스를 만드는 것이 더 나을 수도 있다.

인덱스는 항상 검색에만 사용되는 것이 아닌 것을 인지해야한다.

또한 [여러 컬럼을 Index로 지정할 때는 카디널리가 높은 순으로 인덱스를 생성하는 것이 더 효율적이다.](https://jojoldu.tistory.com/243)

---

## 3. AOP, ThreadLocal을 활용하여 사용자 인증/인가 로직 간소화

### 왜 이런 과정이 필요했는지?

기존 코드에는 특정 API 컨트롤러마다 사용자 인증 정보를 가져오는 로직이 반복되고있었다.

컨트롤러에서 이에 대한 관심사를 해결하는 것 보다는 이를 분리하는게 더 역할에 맞다고 생각해서 이를 분리하기로 했다.

### 구체적으로 어떻게 구현한건지?

HTTP Connection을 맺고 있는 Thread의 ThreadLocal에 서버에서 직접 발급하고 데이터베이스에서 관리하는 사용자의 UUID를 등록된 인증 정보를 보관하도록 하고

이 인증 정보를 사용할 수 있는 로직을 전역적으로 선언하여 Spring 내부의 계층에서 자유롭게 사용할 수 있는 로직을 작성했다.

그리고 이 로직을 사용할 수 있는 대상을 애노테이션으로 지정할 수 있게 하여 반복되어 등장하는 사용자 인증 정보를 꺼내는 로직을 제거했다.

### 사용자는 그러면 어떻게 자신의 UUID를 가지고 있는가?

클라이언트의 로컬 스토리지나 내부 DB에 저장하여 매 요청마다 인증 헤더에 실어 보내야한다.

### 해당 UUID가 탈취되었을 때의 문제점과 해결방안은?

DB에서 탈취된 것으로 판단된 UUID를 제거하여 피해를 막는 사후조치를 해야할 것 같다.

### 이 과정 자체가 그러면 토큰 기반 방식의 인증 방법일까? 세션 기반 방식의 인증 방법일까?

세션 기반 인증 방식으로 볼 수 있을 것 같다.

#### 근거

사용자의 UUID를 서버에서 직접 발급하고 서버 내부에서 관리하는 것이므로 세션 기반 인증 방식에 가깝다고 할 수 있을 것 같다.

하지만 서버 내부의 메모리에서 해당 인증 정보를 관리하는 것이 아닌 DB에 저장되어있는 내용을 관리하는 것이기 때문에 완전한 세션방식이라고 하기엔 조금 어려울 수도 있을 것 같다.

세션 기반 인증에서는 서버 측에서 세션을 관리하고, 클라이언트에게 세션 ID를 부여하여 이를 사용자 식별에 활용한다.

### 공격자로부터 클라이언트의 인증 정보가 탈취되었음을 서버측에서는 어떻게 알 수 있을까?

- 클라이언트의 UUID가 이전에 없던 위치에서 사용되었거나, 단기간 내에 많은 요청이 발생하는 경우 이상행동으로 간주하여 해당 세션을 무효화한다.

- 클라이언트의 로그인 위치를 기록하고, 동일한 UUID가 다른 지역에서 사용되는 경우 해당 세션을 무효화한다.

### 토큰 기반 인증 방식 장/단점

- 장점 1. 확장성과 분산화
    - JWT는 토큰을 생성하고 검증하는 키를 기반으로 동작하며, 토큰에 필요한 정보를 담을 수 있어서 서버 간에 토큰을 공유하거나 전달할 수 있어 확장성이 뛰어나고 분산 환경에서 사용하기 용이하다.

- 장점 2. 상태 없음(Stateless)
    - 서버 측에서 토큰을 검증하고 필요한 정보를 추출하므로, 서버는 클라이언트의 상태를 저장할 필요가 없어 리소스가 절약 될 수 있다.

- 장점 3. 유연한 사용자 권한 관리
    - 토큰 내에 사용자 권한과 관련된 정보를 포함하여 사용자 권한 관리가 용이하며, 토큰의 내용을 이용하여 권한 검사를 수행할 수 있다.

- 단점 1. 토큰 크기와 보안
    - JWT는 탈취될 가능성이 있다. 중요한 정보를 토큰에 포함시키면 보안 문제가 발생할 수 있다.

- 단점 2. 토큰 유효성 검증의 어려움
    - 토큰이 변조되지 않았는지 확인하기 위해 서명을 검증해야 하기 때문에 서명 검증 과정이 추가로 필요하며, 이에 따른 복잡성이 발생할 수 있다.

### 서버 측 세션(Session) 기반 인증 방식 장/단점

- 장점 1. 보안성
    - 세션은 서버에 저장되므로 클라이언트에 노출되지 않는다. 토큰 기반 인증에 비해 보안성이 높다.

- 장점 2. 세션 탈취 시 대처가능
    - 세션을 사용하면 만료 시간을 쉽게 조절하고 조절할 수 있으며, 만료 시간이 지나면 자동으로 세션을 무효화시킬 수 있다.

- 단점 1. 상태 유지
    - 세션은 서버 측에서 상태를 유지해야 하므로, 서버의 메모리를 사용하게 되어 클라이언트가 많을 때 성능 저하가 발생할 수 있다.

- 단점 2. 확장성
    - 분산 환경에서 각 서버마다 발급하는 세션을 관리하기 위해 세션 클러스터를 운영해야하는 복잡성이 증가한다.

---

## 4. GC 튜닝 (JVM의 구조와 GC의 동작 원리)


### 참고자료

### JVM 구조

![JVM: Architecture](https://techvidvan.com/tutorials/wp-content/uploads/sites/2/2020/06/JVM-Model.jpg)

크게 분류하자면 `Class Loader`, `Memory`, `Execution Engine`으로 나눌 수 있다.

---

#### Class Loader

[ClassLoader](https://k-diger.github.io/posts/ClassLoader)

---

#### JVM Memory

[ClassLoader](https://k-diger.github.io/posts/JVM-Memory)

---

#### Execution Engine

[Execution Engine](https://k-diger.github.io/posts/Execution-Engine)

---

#### Execution Engine - JIT Compiler

[JIT Compiler](https://k-diger.github.io/posts/JITCompiler)

---

#### Execution Engine - Garbage Collector

[Garbage Collector](https://k-diger.github.io/posts/JVM-GC)
