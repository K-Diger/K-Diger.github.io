---

title: 기본이 중요하다
date: 2023-09-30
categories: []
tags: []
layout: post
toc: true
math: true
mermaid: true

---

# Resume, Portfolio

## SUWIKI

### 강의평가 작성 시 비관적 락을 활용한 동시성 문제를 해결한 구체적인 상황

A라는 강의 레코드에 X, Y 가 각각 값을 올리고 내리는 요청이 동시에 발생했다.

레코드의 값을 증가시키기위 위해 SELECT 하는 구문과, 값을 감소시키기 위해 SELECT 하는 구문이 동시에 발생했고

커밋되는 시점이 달라 값을 증가시킨 요청이 커밋되었음에도 값을 감소시키는 요청이 커밋되어 변경사항을 덮어 씌우는 현상이 발생했다.

동시성 문제를 해결하는 방법을 알아보는 중 DBMS에서 충돌이 발생하지 않는 상황을 가정하여 애플리케이션 단위에서 동시성을 처리하는 낙관적 락과 DBMS에서 충돌이 발생하는 상황을 가정하는 비관적 락의 차이를 학습하고 비관적 락을 적용하여 해결하기로 결정했다.

이 방법을 적용하게 된 근거로는 각 방식의 장/단점을 따져보았는데

낙관적 락의 장/단점으로는

- 실제로 Lock을 거는 것이 아니기 때문에 성능저하의 우려가 없다.
- 하지만 충돌이 발생해서 롤백을 해야하는 경우 수동으로 해당 데이터의 내용을 모두 롤백하는 로직을 만들어야해서 복잡해질 수 있다.

비관적 락의 장/단점으로는

- Lock을 통해 데이터의 무결성을 보장할 수 있다. 그리고 그럼에도 충돌이 발생했을 경우에는 롤백연산을 한 번만 수행해도 된다.
- 하지만 Lock을 거는 것으로 인한 리소스 경쟁으로 성능 저하가 발생할 수 있다.

그리고 비관적 락에도 종류가 있는데

특정 레코드에 접근했을 때 다른 트랜잭션에서 읽기만 가능하게 하는 `공유 락`, 읽기 및 쓰기 모두 불가능한 `베타 락`이라는 종류가 있다.

이 차이점을 알아본 후 JPA가 지원하는 `@Lock`애노테이션의 `PessimisticRead`옵션으로 해당 문제를 해결했다.


---

## SHORTS

### 인덱스를 통해 150만건이 담긴 데이터베이스 내 BETWEEN 조건 질의시 성능 개선

**보조 인덱스를 어떤 컬럼을 지정해야하는가?** 를 고민하기 시작했다.

인덱싱의 원리의 따르면 보조 인덱스는 **조회할 때 사용할 조건 컬럼**이 되어야하고 **되도록 중복되지 않는 것**이 성능 개선에 더 좋다고 한다.

위 사항을 고려하여 조회할 테이블의 레코드를 살펴보면 어떤 것을 보조 인덱스로 지정할 지 결정하면된다.

Index를 적용하지 않았을 때 실행 계획을 통한 성능 분석

```mysql
EXPLAIN ANALYZE
SELECT *
FROM news
WHERE created_at BETWEEN '2023-07-07 10:00:00' AND '2023-07-07 11:00:00'
  AND title LIKE '%입력값%';
```

위와 같은 쿼리를 날렸을 때의 결과는 아래와 같다.

```text
(news.created_at between '2023-07-07 10:00:00' and '2023-07-07 11:00:00')
(cost=83282.06 rows=26888) (actual time=7404.655..19644.905 rows=2027 loops=1)
-> Table scan on news  (cost=83282.06 rows=242017) (actual time=5.829..19139.414 rows=305977 loops=1)
```

인덱스를 적용하지 않았을 땐 5.8초 ~ 19139.414 초가 걸릴 수 있다.

인덱스를 적용한 후 실행 계획을 다시 조회해보면 아래와 같다.

```text
with index condition: (news.created_at between '2023-07-07 10:00:00' and '2023-07-07 11:00:00')
(cost=2088.81 rows=2027) (actual time=2.678..57.552 rows=2027 loops=1)
```

인덱스를 적용했을 땐 2.678초 ~ 57.552 초가 걸릴 수 있다고 한다.

가장 빠르게 쿼리된 상황에만 보더라도 약 50%가 성능 개선된 것으로 볼 수 있다.

그럼 인덱스를 쓰는게 무작정 좋은 것인지는 조금 더 따져봐야한다.

#### 우선 모든 컬럼을 인덱스로 잡게된다면 어떻게 될까?

- 만약 컬럼이 50가지 100가지 등등 많은 데이터를 보유하고 있다면 매 레코드를 추가할 때 마다 해당 레코드를 추가하는 부가적인 리소스가 발생하게 되어 데이터 삽입이 매우 느리게 될 수 있다.
  - 인덱스의 내부 구현이 LinkedList와 유사한 B-Tree방식으로 구현되어있기 때문이다.
  - 삽입/변경/삭제 등이 자주 일어나는 테이블에는 적절한 방법이 아니다.

- DBMS에도 인덱스를 관리하기 위한 추가적인 저장공간 리소스가 소모된다.
  - 인덱스는 일반적으로 10% ~ 20%의 공간을 추가로 요구한다.

- 책의 내용이 1000페이지인데 500페이지 쯤에서 내용을 추가해야한다고 해보자
  - 이 상황에선 당연하게도 페이지의 내용을 추가하는 것과 더불어 인덱스를 관리하는 목차 또한 모두 고쳐야한다.

결론적으로 인덱스는 대용량 테이블에 적용한다면 성능 개선을 기대할 수 있지만

그렇지 않다면 오히려 리소스를 더 사용하고, 조회 성능 까지도 느리게 만들 수 있다.

---

# JVM Language

## JVM에서의 `autoboxing`이란 어떤 현상을 말하는 걸까?

## `interface default implementation`이란? `abstract class`를 상속받는 것과 기본 구현을 들고 있는 `interface`를 `implements`하는 것은 어떤 차이가 있나?

## `Java stream method`중 `map` 과 `flatMap` 의 차이는 무엇인가?



---

# JVM Architecture

---

# OOP/Design Pattern


---

# Test

---

# Spring




---

# JPA

---

# DBMS

---

# Cache

---

