---

title: Item 8. finalizer 와 cleaner 사용을 피하라

date: 2022-08-15
categories: [Effective-Java]
tags: [Finalizer, Cleaner]
layout: post
toc: true
math: true
mermaid: true

---

# Java 의 두 가지 소멸자

### finalizer

실행 시점을 예측할 수 없고, 오동작-낮은성능-이식성 문제의 원인이 된다.

Java 9 부터는 Deprecated 가 되어 cleaner를 대안으로 소개한다.

### cleaner

finalizer 보다는 덜 위험하지만, 여전히 실행 시점을 예측할 수 없고, 느리다.

## finalizer, cleaner 존재 목적

사용하지 않은 객체를 Heap 영역에서 제거시키기 위함. (GC 구현체가 알아서 사용한다.)

---

# Finalizer - Cleaner 왜 쓰지 말아야 할까?

### 이유 1.
finalizer Cleaner 는 사용되는 시점이 모호할 뿐 만 아니라 코드로 적어놓았다 한들, 사용될지 안될지도 보장되지 않는다..

따라서 상태를 영구적으로 수정하는 작업에서 **절대** finalizer, cleaner 를 사용하면 안된다.

---

### 이유 2.

finalize 동작 중 발생한 예외는 무시되고, 처리할 작업이 남아있더라도 애플리케이션이 종료된다.

심각한 RunTime Error 를 발생할 수 있는 가능성을 활짝 열어두게 되는 것이다.

---

### 이유 3.

가비지 컬렉터에 등록되어있는 finalizer 알고리즘이 있는데, 프로그래머가 굳이굳이 본인이 수동으로

finalizer 를 하게되면, 해당 알고리즘에 문제가 생기는지 심각한 성능 차이가 생기게 된다.

> 간단한 객체를 생성하고 Head 영역에 삭제할 때 성능 지표
>
> GC 에게 맡겼을 때 : 12ns
>
> 수동으로 진행했을 때 : 550ns

---

### 이유 4.

finalizer 를 사용한 클래스는 취약점이 생기게 된다.

생성자, 직렬화 과정에서 예외가 발생할 때, 생성이 되다 중지된 객체에서 하위 클래스의 finalizer 가 수행될 수 있게 된다.

이게 무슨 말이냐면, A라는 객체가 50% 정도는 생기게 된 상태라서, A 객체가 생성된 시점부터 A 객체를 상속받는 B라는 객체가 있을 때

B 객체에서 finalizer 가 수행될 수 있게 되는 것이다.

그리고 이 B 의 finalizer 가 static 필드에 자신의 참조를 할당하여, 가비지 컬렉터가 수집하지 못하게 할 수 있다.

이렇게되면.. B 에서 A에게 상속받은 기능을 사용하려하는데, 사용이 안될 상황이 벌어지고 이는 찾을 수 없는 오류로 남게 될 것이다.

---

# 그럼에도 불구하고 finalizer 가 어디에서 쓰이는가...?

### 쓰임새 1.
자원의 소유자가 close 메서드를 소출하지 않는 것을 대비하여

자원을 늦게 회수하더라도, 회수하지 않은 것을 방지하기 위함

### 쓰임새 2.

네티이브 피어와 연결된 객체이다.

네이티브 피어는, 자바 객체가 네이티브 메서드(다른 언어로 제작된 메서드)를 통해 기능을 위임받은 객체를 말한다.

네이티브 피어는 자바 객체가 아니므로, GC 가 회수하지 못한다.

이럴때가 finalizer가 사용되기 좋은 상황이다.

finalizer 로 성능 저하가 우려된다면, close 메서드를 사용해야한다.
